<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Charlton Austin</title>
    <link>https://charltonaustin.com/tags/algorithms/</link>
    <description>Recent content in algorithms on Charlton Austin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 03 Aug 2016 09:03:54 -0400</lastBuildDate>
    
	<atom:link href="https://charltonaustin.com/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Binary Search Of Sorted Array In Clojure Basic Algorithms Part Three</title>
      <link>https://charltonaustin.com/posts/binary-search-of-sorted-array-in-clojure-basic-algorithms-part-three/</link>
      <pubDate>Wed, 03 Aug 2016 09:03:54 -0400</pubDate>
      
      <guid>https://charltonaustin.com/posts/binary-search-of-sorted-array-in-clojure-basic-algorithms-part-three/</guid>
      <description>The problem Find an element in a sorted array using binary search
The solution The solution is pretty straight forward. I added in some printlns to get a sense of how we drill down in the recursion to find the element.
(defn binary-search [v value] (loop [low 0 high (dec (count v)) depth 0] (let [half-way (quot (+ high low) 2)] (do (println (str &amp;#34;half-way is &amp;#34; half-way)) (println (str &amp;#34;low is &amp;#34; low)) (println (str &amp;#34;high is &amp;#34; high)) (println (str &amp;#34;depth is &amp;#34; depth)) (if (&amp;lt;= high (inc low)) (cond (= value (v low)) low (= value (v high)) high :else nil) (let [middle (quot (+ low high) 2)] (if (&amp;lt; (v middle) value) (recur (inc middle) high (inc depth)) (recur low middle (inc depth))))))))) You can call the function like this:</description>
    </item>
    
  </channel>
</rss>